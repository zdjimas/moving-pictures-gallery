 // filename: suno-proxy-worker.js
const CORS = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'GET,OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type,Range',
  'Access-Control-Expose-Headers': 'Accept-Ranges,Content-Length,Content-Range,Content-Type'
};
const UA = 'Mozilla/5.0 (compatible; SunoRadioProxy/1.0)';

export default {
  async fetch(req) {
    if (req.method === 'OPTIONS') return new Response(null, { headers: CORS });

    const { searchParams } = new URL(req.url);
    const raw = searchParams.get('u');
    if (!raw) return new Response('Missing u param', { status: 400, headers: CORS });

    // If caller already passed a direct audio URL, just stream it.
    if (/\.(mp3|m4a|aac|wav|ogg|m3u8)(\?|$)/i.test(raw)) {
      return stream(raw);
    }

    // If it's a Suno share page, try to discover an audio URL.
    try {
      const share = new URL(raw);
      const isSunoShare = share.hostname.endsWith('suno.com') && share.pathname.startsWith('/s/');
      if (!isSunoShare) return new Response('Unsupported URL', { status: 400, headers: CORS });

      const page = await fetch(raw, { headers: { 'User-Agent': UA } });
      const html = await page.text();

      // 1) Scrape any obvious audio URLs on the page (mp3/m3u8 etc.)
      const found = [];
      const rx = /(https?:\/\/[^"'\\s]+\\.(?:mp3|m4a|aac|wav|ogg|m3u8)[^"'\\s]*)/gi;
      let m; while ((m = rx.exec(html)) !== null) found.push(m[1]);

      // 2) Fallback guesses based on share id pattern
      const id = share.pathname.split('/').pop();
      if (id) {
        found.push(`https://cdn1.suno.ai/${id}.mp3`);
        found.push(`https://cdn2.suno.ai/${id}.mp3`);
        found.push(`https://cdn1.suno.ai/${id}.m4a`);
      }

      // Try candidates in order until one streams
      for (const u of found) {
        const test = await fetch(u, { method: 'HEAD', headers: { 'User-Agent': UA } });
        const ct = test.headers.get('content-type') || '';
        if (test.ok && (ct.startsWith('audio/') || ct.includes('mpegurl'))) {
          return stream(u);
        }
      }

      return new Response('No playable audio found for this share URL.', { status: 404, headers: CORS });
    } catch (e) {
      return new Response('Resolution error', { status: 500, headers: CORS });
    }

    async function stream(u) {
      const r = await fetch(u, { headers: { 'User-Agent': UA }, redirect: 'follow' });
      // Pass through byte-range streaming and content type
      const headers = new Headers(r.headers);
      for (const [k, v] of Object.entries(CORS)) headers.set(k, v);
      return new Response(r.body, { status: r.status, headers });
    }
  }
};
